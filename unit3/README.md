# 単体テストの構造的解析

## 単体テストの構造

### AAA パターン

- Arrange（準備）
  - テストケースの事前条件を満たすようにテスト対象のシステムとその依存を状態を設定する
- Act（実行）
  - テスト対象のシステムを実行する
- Assert（検証）
  - テスト対象のシステムの実行結果を検証する

例）

```
public class Calculator {
    public double Sum(double first, double second) {
        return first + second;
    }
}
```

```
public class CalculatorTest {
  <!-- テストケースであることを示すxUnitの属性 -->
    [Fact]
    <!-- テストケースの名前 -->
    public void Sum_of_two_numbers() {
        // Arrange
        double first = 10;
        double second = 20;
        var calculator = new Calculator();

        // Act
        double result = calculator.Sum(first, second);

        // Assert
        Assert.Equal(3, result);
    }
}
```

ほとんどの場合は上記のように 3 つの順序でテストケースを作成していくことは問題ないが、これとは別の方法として確認フェーズから書き始めるという方法もある。特にテスト駆動開発の場合、機能を作成する前に失敗するテストケースを作成するようになっているためその機能を十分に把握していないことがある。そのため想定する振る舞いをテストケースにあらかじめ書き出しておき、その書き出した想定に見合ったシステムにするためにはどう開発するのかを考えるようにする。

**準備(Arrange)フェーズがもっとも大きくなる**
あまりに大きくなる場合は、その部分をプライベートメソッドにしておくといい。このように準備フェーズのコードをテストケース間で共有することに関する有用なパターンとしてオブジェクトマザーと、テストデータビルダーがある。

**実行(Act)フェーズのコードが 1 行を超す場合は注意が必要**
通常は 1 行で収まる。複数行になる場合は、API がきちんと設計されていないことを示唆している。

**確認(Assert)フェーズで確認する項目はどのくらいあれば良いか**
「単体」は一単位のコードではなく、1 つの振る舞いであるため、1 つのテストケースでその全てを検証することは不自然ではない。しかし、テスト対象のシステムが戻り値として返すオブジェクトの全フィールドの値を確認しているのであれば、そのよううなことをするのではなく、そのオブジェクトが同等であることを確認する手段を用意する。

### 単体テストにおいて回避すべきこと

- 同じフェーズを複数用意すること
  - 1 つのテストケースで複数のフェーズを実行することは複数の振る舞いを検証していることになる
- if 文の使用
  - 分岐のない単純な流れにするべき
  - 分岐のある場合は複数のことを検証することになる

## テストケース間で共有するテスト・フィクスチャ

適切ではない使い方<br>
[test code](./sample3.7.java)

こうすることで ↑ のような 2 つのテストケースはテストフィクスチャを準備するのに同じロジックを使うようになる。なので準備フェーズの内容をそのまま CustomerTests コンストラクタに持っていき準備フェーズを実装すなくてすむ。
**しかし、この方法には重大な欠点が 2 点ある**

- テストケース間の結びつきが強くなってしまう
- テストケースの可読性が下がる

以下で詳しく説明する。

### コンストラクタの利用はテストケース間の結びつきを強めてしまう

もし、どちらかのテストケースでテストフィクスチャの準備に関するロジックを変更しなくてはいけなくなってしまった場合、その変更がもう一方にも影響が及んでしまう

```
_store.addInventory(Product.Shampoo, 10);
```

から

```
_store.addInventory(Product.Shampoo, 15);
```

に変えた結果、テストケースが不必要に失敗してしまうことがある。
そうなると**1 つのテストケースに関する修正が他のテストケースに影響を与えてしまう**

### コンストラクタの利用はテストケース間の読みやすさを損なわせてしまう

テストケースには準備フェーズのロジックがないため何を検証しようとしているかが完全には理解できない。

### テスト・フィクスチャに関するコードを共有するためのより良い方法

- テストクラスのファクトリメソッドを導入する
  [test code](./sample3.8.java)

このように共通に利用するテスト・フィクスチャを作成するメソッドをテストクラスに追加することで、コード量を減らすことと同時に各テストケースで何が行われているのかが完全に理解できるようになる。加えて、この種のファクトリメソッドが十分に汎用的になっていれば、（つまりテストケース側でどのようなテスト・フィクスチャを作成するのかを指定できるようになっていれば）テストケース間の結びつきが弱くなり、テストケースの可読性が高くなる。<br>
メソッド名と渡される引数を見ることで中身を見なくてもどのようなテスト・フィクスチャを作成するのかが理解できる。また、引数で渡すことで、事前条件の異なるテスト・フィクスチャを作成することができるため共有もしやすい。

## 単体テストでの命名

**もっとも役に立たない命名規則**

```
{テスト対象メソッド}_{事前条件}_{想定する結果}
```

この命名に実用性がない理由は"目を向けている部分が振る舞いではなく実装の詳細"だからである。

```
<!-- Sum_２つの数値_合計を返す -->
public void Sum_TwoNumbers_ReturnSum();
```

ではなく、

```
<!-- 2つの数値の合計 -->
public void Sum_of_two_numbers();
```

### 命名の指針

- 厳格な命名規則に縛られないようにする
- 問題領域のことに精通している非開発者に対してどのような検証をするのかが伝わるようにする
- \_を使って区切る

例）配達サービス(delivery service)の場合に、過去の日付は選択できないことを検証するテストメソッド

```
<!-- IsDeliveryValid_不正な日付_Falseを返す -->
public void IsDeliveryValid_InvalidDate_ReturnsFalse();
```

厳格な命名規則に縛れてしまっているためわかりにくくなっている。これを普通の言い回しに書き換える。

```
<!-- 不正な日付が指定された配達は不正だと見做されるべきである -->
public void Delivery_with_invalid_date_should_be_considered_invalid();
```

「配達日が不正」がが正確にはどういう意味かが明確ではないので、書き換える。

```
<!-- 過去の日付が指定された配達は不正だと見做されるべきである -->
public void Delivery_with_past_date_should_be_considered_invalid();
```
