# 単体テストの 3 つの手法

### 出力値ベースのテスト（戻り値を確認するテスト）

**テスト対象のコードに入力値を渡したあと、そこから返される結果を検証する**

基本的には、処理を行った後もテスト対象システムの状態とその協力者オブジェクトの状態が変わらない場合。検証対象は戻り値のみ。

<br>

### 状態ベースのテスト(状態を確認するテスト)

**検証する処理の実行が終わった後にテスト対象の状態を検証する**

「状態」はテスト対象のシステムの状態、その協力者オブジェクトの状態、データベースやファイルシステムのプロセス外依存の状態を指す。

<br>

### コミュニケーションベースのテスト(オブジェクト間のやり取りを確認するテスト)

モックを用いてテスト対象のシステムとその協力者オブジェクトとの間で行われるコミュニケーションを検証する。

<br>

## 3 つの手法の比較

4 章で述べた 4 つの柱をベースに比較していく。

- 退行(regression)に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

### "退行(regression)に対する保護"の観点での比較と"迅速なフィードバック"の観点での比較

退行に対する保護は単体テストの手法ではなくプロダクションコードの以下の 3 つの要素のよってどのくらい備わるかが変わる。

- テスト時に実行されるコードの量
- コードの複雑さ
- ドメインにおける重要性

一般的に単体テストによって実行されるプロダクションコードの量は単体テストの違いによって差が出るのではなく、単体テストを作成する人の判断によって差が出る。これと同じことがプロダクションコードの複雑さやドメインにおける重要性にも言える。コミュニケーションベースのテストは例外で、この手法をあまりにも使いすぎる(モックを多用しすぎる)と、検証されるプロダクションコードの量が減ってしまう。しかしこれも単体テストの作成者が招く事態。<br>
同じように、単体テストの手法が迅速なフィードバックに影響を与えることはほとんどない。

<br>

### "リファクタリングへの耐性"の観点での比較

偽陽性(false positive)がリファクタリングの際にどのくらい発生するかによって判断が可能。

偽陽性の発生を最も抑えるのは**出力値ベースのテスト**。なぜなら、このテストが実装の詳細に結びつくケースはテスト対象のメソッド自体が実装の詳細である場合だけであるからである。

一方、状態ベースのテストはテスト対象のメソッドの実行に加え、そのメソッドの実行によって変更されたオブジェクトの状態もみることになるため偽陽性が発生しやすい。

さらにコミュニケーションベースのテストは 3 つの手法の中で最も脆弱。
テストケースがテスト・ダブルととのやり取りを検証していると、そのテストケースは壊れやすい傾向がある。（スタブの場合は必ず壊れる）<br>
モックが効果を発揮するのは、**アプリケーションの境界を超えて、行われるコミュニケーションを検証し、かつ、そのコミュニケーションによって発生した副作用が外部からも確認できる場合**のみ。

プロダクションコードに対して、適切なカプセル化を施すことや、観察可能な振る舞いのみを検証するようにしていれば偽陽性の発生を抑えることはできる。

<br>

### "保守のしやすさ"の観点での比較

<h4>出力値ベース</h4>
コード量が少なく、簡潔になるため、最も保守がしやすい。この観点において、出力値ベースのテストは最も優れていると言える。

<h4>状態ベース</h4>

多くの場合、戻り値よりも状態を検証する方がより多くのコードを必要とするため、保守は難しくなる。
例）[test code](./sample6.4.java)

検証フェーズでのコード量が多くなってしまう。ヘルパーメソッドを作成する方法もあるが、その作成自体にもそれなりの時間と労力を使う。<br>

その他にも状態ベースのテストのコードを減らす方法として「確認対象となるオブジェクトのクラスに対して同等であることを確認するための手段を提供させる」方法もある。
例）[test code](./sample6.6.java)
確認対象の Comment クラスを**値オブジェクト**として作り直すことで識別子ではなく、値として比較できるようにする。

<h4>コミュニケーションベース</h4>

他の 2 つよりも劣る。テストケースにの多くのコードを記述する必要があり、かつ、モックの連鎖(モックやスタブが他もモックやスタブを返すようになり、さらに、そのことが何度も繰り返されてしまうこと)起こってしまうことがあるため。

上記を踏まえて、基本的には"出力値ベースのテスト"を使うことにつとめることが好ましい。しかし、簡単ではない。なぜなら、プロダクションコードが関数型プログラミングで書かれている必要があるためである。そこで次から他の 2 つの単体テストを出力値ベースのテストに書き換えるテクニックを述べる。

## 関数型アーキテクチャについて

### 関数型プログラミングとは

<h4>数学的関数を用いたプログラミングのこと</h4>
数学的関数は、純粋関数とも呼ばれ、隠れた入力や出力がない関数のこと。つまり、全ての入力と出力はメソッド名、引数、戻り値の型で構成されるメソッド・シグネチャに明示されることになる。
例）
```
public decimal CalculateDiscount(Product[] products)
{
  decimal discount = products.Length + 0.01m;
  return Math.Min(discount, 0.2m);
}
```

上記は 1 つの入力(Product の配列)と 1 つの出力(decimal 型の割引率)を持っていて、そのことがメソッド・シグネチャに明示されている。また副作用を起こすこともない。

例 2）

```
public int Increment(int x)
{
  return x + 1;
}
```

上記は数学的関数で、次の 2 つの表現は同等の意味になる。

```
int y = Increment(1);
int y = 5;
```

```
int x = 0;
public int Increment()
{
  x++;
  return x;
}
```

しかしこれ(↑)は数学的関数ではない。なぜなら、このメソッドの戻り値はこのメソッドの全ての出力を表現していないため、このメソッドを呼びだしている部分を値に置き換えると振る舞いが変わってしまうため。（メソッドの結果が x の値に依存している、同じメソッド呼び出しでも異なる結果になる）

このような数学的関数の性質は、テストケースが簡潔になる。

### 関数型アーキテクチャとは何か？

とはいえ、副作用を全く起こさないアプリケーションを構築することは不可能。関数型プログラミングが目指してることは副作用を取り除くことではなく、**ビジネスロジックを扱うコードと副作用を起こすコードを分離すること**。**副作用をビジネスオペレーションの最初や最後に持っていく**ことで分離がしやすなる。

ビジネスロジックと副作用の分離は以下の 2 種類のコードの分類することで行われる。

- 決定を下すコード
  - 数学的関数を使って書くことができる
- 決定に基づくアクションを実行するコード
  - 数学的関数によって下された決定を観察可能な振る舞いの一部に変換する

決定を下すコードは**関数的核(functional core)**もしくは**不変核(immutable core)**と呼ばれ、決定に基づくアクションを実行するコードは**可変殻(mutable shell)**と呼ばれる。

1. 可変殻にて、関数的核に渡す全ての入力値が集められる。
2. 関数的核は可変殻から受け取った入力値を元に決定を下す。
3. 可変殻は関数的核が下した決定をもとに副作用を起こす。

## 関数型アーキテクチャおよび出力値ベースのテストへの移行

1. プロセス外依存の利用からモックの利用への移行
2. モックの利用から関数型アーキテクチャの利用への移行

サンプルプロジェクトを通して、上記の 1,2 の手順で出力値ベースのテストへの移行を行う。

<h4>サンプルプロジェクト</h4>

**訪問記録システム**

平文のテキストファイルに訪問者を記録しており、訪れるたびに名前と日時をファイルの最後に追加する。もし、すでに書き込まれている記録の数がファイルの上限に達していたら新たなインデックス(番号)を持つファイルを作成し、書き込む。

![alt text](<スクリーンショット 2025-01-12 19.17.51.png>)

[sample code](./sample6.8.java)

↑ の状態は AuditManager クラスはファイルシステムと深く結びついているため、そのままテストすることは簡単ではない。最初に訪問者ファイルを対象ディレクトリに配置して、その上にテスト対象の処理が終わったらファイルを読み込んで中身を確認して、最後に取り除かなくてはならない。

テストを行いにくくなっている状態はファイルシステムを直接扱っているため。このファイルは共有依存のため、他のテストケースで使用されると状態が変わり、テストが失敗してしまう可能性がある。また保守もしにくい状態。

### モックを用いることによる単体テストとファイルシステムの分離

プロセス外依存をモックに置き換えることで問題を解決できる。プロダクションコードに定義されている全てのファイル操作を IFileSystem インターフェースに置き換える。そしてそのインターフェースの型を持つオブジェクトが AuditManager クラスのコンストラクタに注入されるようにリファクタリングを行う。これでテスト時にファイルシステムをモックに置き換えることができる。

[sample code](./sample6.9.java)

これで`AuditManager`とファイルシステムを分離できたので共有依存であったファイルシステムは複数のテストケース間で共有されることはなくなる。

よって、モックを使用した改善 ver のコードが以下となる。

[sample code](./sample6.11.java)

これが、正当なモックの使い方である。この訪問者システムが作成するファイルは、エンドユーザーからもアクセスが予想されることが想定されるもの。そのため、ファイルシステムとのコミュニケーション、および、その際に発生する副作用は訪問者記録システムの観察可能な振る舞いの一部となる。<br>このようなモックの使い方は、どのテストケースの実際のファイルシステムにはアクセスしなくなったので実行に時間が掛からなくなった。さらにテストケースを実行した後も、他のテストケースに影響を与えることは無くなった。
しかし、まだ改善できる部分がある。準備フェースの複雑さはリファクタリング前とさほど変わっていない。

### 関数型アーキテクチャへの移行

AuditManager クラスにモックを注入できるようにすることでファイルシステムに対する副作用を隠していた部分をリファクタリングして、 AuditManager クラスから副作用を完全に取り除くようにしていく。(AuditManager クラスを関数的核にする。)
