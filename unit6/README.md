# 単体テストの 3 つの手法

### 出力値ベースのテスト（戻り値を確認するテスト）

**テスト対象のコードに入力値を渡したあと、そこから返される結果を検証する**

基本的には、処理を行った後もテスト対象システムの状態とその協力者オブジェクトの状態が変わらない場合。検証対象は戻り値のみ。

<br>

### 状態ベースのテスト(状態を確認するテスト)

**検証する処理の実行が終わった後にテスト対象の状態を検証する**

「状態」はテスト対象のシステムの状態、その協力者オブジェクトの状態、データベースやファイルシステムのプロセス外依存の状態を指す。

<br>

### コミュニケーションベースのテスト(オブジェクト間のやり取りを確認するテスト)

モックを用いてテスト対象のシステムとその協力者オブジェクトとの間で行われるコミュニケーションを検証する。

<br>

## 3 つの手法の比較

4 章で述べた 4 つの柱をベースに比較していく。

- 退行(regression)に対する保護
- リファクタリングへの耐性
- 迅速なフィードバック
- 保守のしやすさ

### "退行(regression)に対する保護"の観点での比較と"迅速なフィードバック"の観点での比較

退行に対する保護は単体テストの手法ではなくプロダクションコードの以下の 3 つの要素のよってどのくらい備わるかが変わる。

- テスト時に実行されるコードの量
- コードの複雑さ
- ドメインにおける重要性

一般的に単体テストによって実行されるプロダクションコードの量は単体テストの違いによって差が出るのではなく、単体テストを作成する人の判断によって差が出る。これと同じことがプロダクションコードの複雑さやドメインにおける重要性にも言える。コミュニケーションベースのテストは例外で、この手法をあまりにも使いすぎる(モックを多用しすぎる)と、検証されるプロダクションコードの量が減ってしまう。しかしこれも単体テストの作成者が招く事態。<br>
同じように、単体テストの手法が迅速なフィードバックに影響を与えることはほとんどない。

<br>

### "リファクタリングへの耐性"の観点での比較

偽陽性(false positive)がリファクタリングの際にどのくらい発生するかによって判断が可能。

偽陽性の発生を最も抑えるのは**出力値ベースのテスト**。なぜなら、このテストが実装の詳細に結びつくケースはテスト対象のメソッド自体が実装の詳細である場合だけであるからである。

一方、状態ベースのテストはテスト対象のメソッドの実行に加え、そのメソッドの実行によって変更されたオブジェクトの状態もみることになるため偽陽性が発生しやすい。
