# モックの利用とテストの壊れやすさ

## モックとスタブの違い

- モック
  - テスト対象システムとその協力者オブジェクトとのやり取りを検証するのに使われるテスト・ダブルのこと。そしてテスト・ダブルにはモックとは別の種類のスタブと呼ばれるものがある。

### テスト・ダブルの種類

テスト・ダブルとは、プロダクションコードには含まれず、テストでしか使われない偽りの依存として表現される全てのものを包括的に意味するもの。

**ダミー、スタブ、スパイ、モック、フェイク**の 5 種類があるが、モック(モック、スパイ)、スタブ(ダミー、スタブ、フェイク)の 2 つに分けることができる。

- モックはテスト対象システムからその依存に向かって行われる**外部に向かう**コニュニケーション(出力)を模倣し、検証するのに使われる。このときモックが模倣するコミュニケーションはテスト対象システムが依存の状態を変えるために行う依存への呼び出しのことになる。
- スタブは依存からテスト対象システムに向かって行われる**内部に向かう**コミュニケーション(入力)を模倣するのに使われる。このときスタブが模倣するコミュニケーションはテスト対象システムが依存からデータを取得するために行うその依存への呼び出しのことになる。

**スタブとのやり取りを決して検証してはならない**
テスト対象のシステムが行うスタブへの呼び出しは、テスト対象システムが生み出す最終的な結果の一部ではなく、その最終的な結果を生み出す一過程にすぎないからである。
必要なデータをそのように取得するかを検証することになるので、リファクタリングへの耐性が低いものとなってしまう。<br>
例）[test code](./sample5.3.java)

このように最終的な結果の一部とはならないものを検証することを**過剰検証**と呼ぶ。

### モックとスタブの両方の性質を持ったテスト・ダブル

例）[test code](./sample5.4.java)

Mock への呼びだしは、異なるメソッドに対して行われている。

- `storeMock`に対してテスト対象システムが処理をする際に必要となるデータを提供させるのに HasEnoughInventory を呼び出している。
- 呼び出したかどうかを検証する際は RemoveInventory を呼び出している。
- 「スタブとのやり取りを検証してはいけない」という原則に違反していない。

### モックとスタブがそれぞれどのようにコマンドとクエリに結びつくか

- コマンド
  - どのような値も返すことではなく(つまり戻り値がない)、副作用を起こすメソッドのこと
  - 例えば、オブジェクトの状態を変更することやファイルシステムのファイルを変更することなどが副作用にあたる
  - テストでは Mock
- クエリ
  - どのような値も返すことであり(つまり戻り値がある)、副作用を起こさないメソッドのこと
  - テストでは Stub

このような分離を明確に行うことはコードの可読性をあげ、メソッド・シグネチャを見ただけで何を行うメソッドかがわかるようになる。

例）

```
<!-- メールを送るという副作用 -->
var mock = new Mock<IEmailGateway>();
mock.Verify(x => x.SendEmail("user@email.com");
```

```
<!-- データベースに対して変更はなく、データを取得するだけのクエリ -->
var stub = new Stub<IDatabase>();
stub.Setup(x => x.GetNumberOfUsers()).Returns(10);
```

## 観察可能な振る舞い(Observable Behavior)と実装の詳細(Implementation Details)

### 観察可能な振る舞いと公開された API との違い

全てのプロダクションコードは以下の 2 つの観点で分類できる

- 公開された API なのか、それとも、プライベート API なのか
- 観察可能な振る舞いなのか、それとも、実装の詳細なのか

API は`private`キーワードがあるためわかりやすいが、振る舞いと実装の詳細はニュアンスの違いになる。<br>
テスト対象のコードがシステムの観察可能な振る舞いの一部になるにはそのコードは次に挙げるもののどちらかでなくてはならない。

- クライアントが目標を達成するために使う公開された**操作**
  - ここでいう操作とは、計算をしたり、副作用を起こしたりするメソッドのこと
- クライアントが目標を達成するために使う公開された**状態**

  - ここでいう状態とは、システムの現時点でのコンディション

観察可能な振る舞い = クライアントが直接使用する機能（public API のうち重要なもの）<br>
実装の詳細 = その機能を実現するための内部の仕組み（private メソッドや内部処理）

↓ が理想

![alt text](<スクリーンショット 2025-01-11 15.46.53.png>)

### 公開された API から漏洩する実装の詳細

システムが隠蔽したい実装の詳細が、公開された API から漏洩するのはなるべく避けたい。
例）[test code](./sample5.5.java)

この場合 public である`Name`と`NormalizeName`は観察可能な振る舞いの一部となっていなくててはならない。`Name`は状態であり、「ユーザー名を変更する」という目標達成に set プロパティが使用されるため条件を満たしているが、`NormalizeName`は操作であり、「ユーザー名を変更する」という目標達成に使用されていないため条件を満たしていない。
![alt text](<スクリーンショット 2025-01-11 16.02.06.png>)

改善 ver
[test code](./sample5.6.java)

理想とすべき API 設計は、<h3>いかなる目標であれ、1 つの操作で目標を達成できる\*\*</h3>ことである。

カプセル化をして不変条件が侵害されないことを保証することができる。

### 状態からの実装の詳細の漏洩

例）[test code](./sample5.7.java)

`SubRenderers`が public である。<br>
このクライアントが達成したいことは「MessageRenderer クラスに渡したメッセージが埋め込まれた HTML を描画させること」つまり目的は、`Render`メソッドだけにある。

## モックの利用とテストの壊れやすさ

### ヘキサゴナルアーキテクチャ

https://qiita.com/cocoa-maemae/items/b08c4cf95d47e314e2dc

- ドメイン層とアプリケーション層の分離
  - ドメイン層はドメイン知識(how-to),アプリケーション層は(what-to)
- アプリケーション内でのコミュニケーション
  - 依存の流れがアプリケーション・サービス層からドメイン層への 1 方向になる
  - ドメイン層は完全に外部の世界から隔離された状態になる

![alt text](<スクリーンショット 2025-01-11 16.45.35.png>)

## システム内コミュニケーションとシステム外コミュニケーション

- システム内コミュニケーションは**実装の詳細**になる
  - クライアントからリクエストを処理する際、ドメイン・クラス間で行われるやり取りは観察可能な振る舞いの一部にはならないため
  - システム外コミュニケーションで意識することは、「後方互換」を維持すること

例）

1. 顧客(Customer)が店舗(Store)から商品(Product)を購入しようとする
2. 店にある商品の数(quantity)を確認する
3. 店にある商品の数を減らす
4. 領収書(Receipt)を顧客にメールで送る
5. 購入処理が成功したことを呼び出し元に伝える
